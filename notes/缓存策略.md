
![avatar](https://camo.githubusercontent.com/4e1a2fff1565062e3c71363f91dd1fba6a5e0d8b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f352f313638316332316530343535326637373f773d3232313326683d39343826663d706e6726733d333131313733)

**一. 缓存位置**
分为四种：
* service worker
* memory cache
* disk cache
* push cache

缓存命中规则：通常会按照以上顺序的优先级进行缓存命中，如果四个都未命中，则再进行接口请求。若能命中缓存，则不进行接口请求，减少了网络请求传输消耗

1. **service worker**
独立于js主线程，运行在浏览器背后的独立线程（浏览器是多线程工作）。使用service worker传输协议必须为HTTPS。 service worker的缓存方法与浏览器的内置缓存机制不同，优先级最高，可以进行自定义缓存哪些文件，如何读取缓存和缓存持续性等

2. **memory cache**
内存中的缓存，读取效率高，时效较短，每次刷新页面时取用的就是memory cache，页面关闭，内存缓存便释放

3. **disk cache**
硬盘中的缓存，读取较慢，容量大，时效性强

浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？

* 对于大文件来说，大概率是不存储在内存中的，反之优先
* 当前系统内存使用率高的话，文件优先存储进硬盘

4. push cache
Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂

以上四种缓存都没命中的话，只能发起请求

**二. 缓存过程**
![avatar](https://camo.githubusercontent.com/ddcaf3e675377ab08192b776f2025869e9d8ca5f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626264363935653735313f773d36373026683d35313226663d706e6726733d313635313332)

浏览器中发起请求会被缓存进行“拦截”，有命中，直接从缓存中读取数据，查找入股没有请求的缓存结果，则发起请求。返回数据后将请求结果存取缓存中（或者使用service worker自定义缓存方式）

* 所以在webpack的配置文件中，我们写output配置时会这样写：

    在name后面加上hash值，不然根据浏览器缓存，重新打包时名字未更改浏览器会认为文件没有更新而继续使用缓存中的版本，造成打包后未更新的问题
``` JavaScript
output: {
   filename: '[name].[chunkhash].js',
   path: path.resolve(__dirname, 'dist')
}
```

**三. 强制缓存**

强缓存：**不会**向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

主要设置cache-control和Expires。强制缓存的缓存策略是依据在某个时间内而进行缓存，假如在该时间内服务端更新内容，但是本地还是不会有更新，除非过了该段缓存时间

**四. 协商缓存**

协商缓存就是强制缓存失效后，浏览器携带**缓存标识**向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。这里有与服务端通信过程。

Etag标识请求示例：
![avatar](https://camo.githubusercontent.com/084e1ed3e9b2a34b24da9b3b945ced05c5898e72/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f342f313638313936626536663262393433383f773d35343626683d32353626663d706e6726733d3131393137)

etag与上次服务端返回的一致，则返回304告诉浏览器使用本地缓存即可。

五. 缓存机制
强制缓存优先于协商缓存，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存

详细的过程如下：
![avatar](https://camo.githubusercontent.com/9c1f83c84574d5f1b22a18591784c8fbe3e8634f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f342f313638313936346439363363356138363f773d35313926683d34363226663d706e6726733d313630373937)