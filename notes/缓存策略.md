
![avatar](https://camo.githubusercontent.com/4e1a2fff1565062e3c71363f91dd1fba6a5e0d8b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f352f313638316332316530343535326637373f773d3232313326683d39343826663d706e6726733d333131313733)

**一. 缓存位置**
分为四种：
* service worker
* memory cache
* disk cache
* push cache

缓存命中规则：通常会按照以上顺序的优先级进行缓存命中，如果四个都未命中，则再进行接口请求。若能命中缓存，则不进行接口请求，减少了网络请求传输消耗

1. **service worker**
独立于js主线程，运行在浏览器背后的独立线程（浏览器是多线程工作）。使用service worker传输协议必须为HTTPS。 service worker的缓存方法与浏览器的内置缓存机制不同，优先级最高，可以进行自定义缓存哪些文件，如何读取缓存和缓存持续性等

2. **memory cache**
内存中的缓存，读取效率高，时效较短，每次刷新页面时取用的就是memory cache，页面关闭，内存缓存便释放

3. **disk cache**
硬盘中的缓存，读取较慢，容量大，时效性强

浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？

* 对于大文件来说，大概率是不存储在内存中的，反之优先
* 当前系统内存使用率高的话，文件优先存储进硬盘

4. push cache
Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂

以上四种缓存都没命中的话，只能发起请求

**二. 缓存过程**
![avatar](https://camo.githubusercontent.com/ddcaf3e675377ab08192b776f2025869e9d8ca5f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f32302f313633376430626264363935653735313f773d36373026683d35313226663d706e6726733d313635313332)

浏览器中发起请求会被缓存进行“拦截”，有命中，直接从缓存中读取数据，查找入股没有请求的缓存结果，则发起请求。返回数据后将请求结果存取缓存中（或者使用service worker自定义缓存方式）

* 所以在webpack的配置文件中，我们写output配置时会这样写：

    在name后面加上hash值，不然根据浏览器缓存，重新打包时名字未更改浏览器会认为文件没有更新而继续使用缓存中的版本，造成打包后未更新的问题
``` JavaScript
output: {
   filename: '[name].[chunkhash].js',
   path: path.resolve(__dirname, 'dist')
}
```

**三. 强制缓存**

强缓存：**不会**向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

主要设置cache-control和Expires。强制缓存的缓存策略是依据在某个时间内而进行缓存，假如在该时间内服务端更新内容，但是本地还是不会有更新，除非过了该段缓存时间

**四. 协商缓存**

协商缓存就是强制缓存失效后，浏览器携带**缓存标识**向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。这里有与服务端通信过程。

Etag标识请求示例：
![avatar](https://camo.githubusercontent.com/084e1ed3e9b2a34b24da9b3b945ced05c5898e72/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f342f313638313936626536663262393433383f773d35343626683d32353626663d706e6726733d3131393137)

etag与上次服务端返回的一致，则返回304告诉浏览器使用本地缓存即可。

五. 缓存机制
强制缓存优先于协商缓存，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存

详细的过程如下：
![avatar](https://camo.githubusercontent.com/9c1f83c84574d5f1b22a18591784c8fbe3e8634f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f312f342f313638313936346439363363356138363f773d35313926683d34363226663d706e6726733d313630373937)

**五. 浏览器的代码缓存**

>对于 V8 编译后的代码 Chrome 有两级缓存：一个是由 V8（Isolate 缓存）维护的**内存缓存**和一个完整序列化的**硬盘缓存**。

>只有在代码执行完成时编译的代码才会被加入到代码缓存， 因此有许多类型的函数尽管稍后执行，但不会被缓存

* isolate缓存：
1. 当 V8 编译脚本时，编译后的脚本以源码为键被存储在一个 hashtable 中（在 V8 的堆中）。
2. 当 Chrome 要求 V8 编译其他脚本的时候，V8 首先检查脚本的源码是否能匹配 hashtable 中的值。如果是，则返回已经存在的字节码。

* 硬盘缓存:
1. 首次请求 JS 文件（即 cold run）时，Chrome 会下载并将其提供给 V8 进行编译。它还将文件存储在浏览器的磁盘缓存中。
2. 当第二次请求 JS 文件（即 warm run）时，Chrome 从浏览器缓存中获取文件并再次将其提供给 V8 进行编译。但是，这次编译的代码被序列化，并作为元数据附加到缓存的脚本文件。
3. 第三次（即 hot run），Chrome 从缓存中获取文件和文件的元数据，并将两者都交给 V8。V8 反序列化元数据，可以跳过编译。

浏览器的代码缓存为了提高加载速度，减少请求。根据代码缓存的知识，可以知晓一些编码的规范：
1. 将库从业务代码中分离
    脚本的每一部分改动会导致整个脚本的缓存失败，从而浏览器会从新加载该脚本。可以将稳定不经常变动的部分放在通用脚本中，单独加载它，在业务逻辑频繁变动时也会直接读取缓存，而不用重新加载该部分内容
2. 利用IIFE（立即执行函数）
    将需要被缓存的函数强制编译，使用IIFE表达式，js引擎探测到它们会立即被编译，并进行缓存
3. 合并小文件
    Chrome 有个代码缓存的最小文件大小限制，现在是 1 Kib 。这意味着小于 1 Kib 的脚本不能被缓存，因为我们认为开销大于收益。
4. 避免使用内联脚本
    HTML 中的内联脚本没有关联外部的源文件，因此不能被上述机制缓存